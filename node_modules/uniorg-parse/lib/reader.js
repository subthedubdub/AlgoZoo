"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _text, _vfile, _location, _offset, _left, _right, _narrows;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reader = void 0;
const vfile_location_1 = __importDefault(require("vfile-location"));
class Reader {
    constructor(vfile) {
        _text.set(this, void 0);
        _vfile.set(this, void 0);
        _location.set(this, void 0);
        /// Current cursor position ignoring the narrowing boundaries.
        _offset.set(this, 0);
        /// Left boundary of the currently active narrowing.
        _left.set(this, void 0);
        /// Right boundary of the currently active narrowing (exclusive).
        _right.set(this, void 0);
        /// Array of currently active narrows.
        _narrows.set(this, []);
        __classPrivateFieldSet(this, _text, vfile.toString());
        __classPrivateFieldSet(this, _left, 0);
        __classPrivateFieldSet(this, _right, __classPrivateFieldGet(this, _text).length);
        __classPrivateFieldSet(this, _vfile, vfile);
        __classPrivateFieldSet(this, _location, vfile_location_1.default(vfile));
    }
    message(reason, offset, ruleId) {
        const point = offset !== undefined ? __classPrivateFieldGet(this, _location).toPoint(offset) : undefined;
        __classPrivateFieldGet(this, _vfile).message(reason, point, ruleId);
    }
    advance(n) {
        if (!n) {
            // do nothing
        }
        else if (typeof n === 'number') {
            __classPrivateFieldSet(this, _offset, __classPrivateFieldGet(this, _offset) + n);
        }
        else if (typeof n === 'string') {
            if (this.rest().startsWith(n)) {
                __classPrivateFieldSet(this, _offset, __classPrivateFieldGet(this, _offset) + n.length);
            }
            else {
                // TODO: raise?
            }
        }
        else {
            __classPrivateFieldSet(this, _offset, __classPrivateFieldGet(this, _offset) + (n.index + n[0].length));
        }
        return n;
    }
    /**
     * Move cursor backwards.
     */
    backoff(n) {
        __classPrivateFieldSet(this, _offset, Math.max(__classPrivateFieldGet(this, _left), __classPrivateFieldGet(this, _offset) - n));
    }
    match(regex) {
        return regex.exec(this.rest());
    }
    lookingAt(regex) {
        const m = this.match(regex);
        return (m === null || m === void 0 ? void 0 : m.index) === 0 ? m : null;
    }
    forceMatch(regex) {
        const m = this.match(regex);
        if (!m) {
            throw new Error(`match error: ${regex} against ${JSON.stringify(this.rest())}`);
        }
        return m;
    }
    forceLookingAt(regex) {
        const m = this.lookingAt(regex);
        if (!m) {
            throw new Error(`match (lookingAt) error: ${regex} against ${JSON.stringify(this.rest())}`);
        }
        return m;
    }
    peek(n) {
        return __classPrivateFieldGet(this, _text).substring(__classPrivateFieldGet(this, _offset), __classPrivateFieldGet(this, _offset) + n);
    }
    line() {
        const rest = this.rest();
        const endl = rest.indexOf('\n');
        return rest.substring(0, endl === -1 ? rest.length : endl + 1);
    }
    rest() {
        return __classPrivateFieldGet(this, _text).substring(__classPrivateFieldGet(this, _offset), __classPrivateFieldGet(this, _right));
    }
    /**
     * Returns string at [left, right).
     *
     * Ignores narrowing.
     */
    substring(left, right) {
        return __classPrivateFieldGet(this, _text).substring(left, right);
    }
    eof() {
        return __classPrivateFieldGet(this, _offset) >= __classPrivateFieldGet(this, _right);
    }
    offset() {
        return __classPrivateFieldGet(this, _offset);
    }
    endOffset() {
        return __classPrivateFieldGet(this, _right);
    }
    resetOffset(offset) {
        __classPrivateFieldSet(this, _offset, offset);
    }
    /**
     * Narrows buffer to the region [`left`, `right`).
     *
     * If `preserveOffset` is false (default), also resets cursor to the
     * start of the narrowing region.
     */
    narrow(left, right, preserveOffset = false) {
        __classPrivateFieldGet(this, _narrows).push({
            prevLeft: __classPrivateFieldGet(this, _left),
            prevRight: __classPrivateFieldGet(this, _right),
            prevOffset: __classPrivateFieldGet(this, _offset),
        });
        __classPrivateFieldSet(this, _left, left);
        __classPrivateFieldSet(this, _right, right);
        if (!preserveOffset) {
            __classPrivateFieldSet(this, _offset, left);
        }
    }
    /**
     * Cancels the previous narrowing operation.
     *
     * If `preserveOffset` is false (default), restores the cursor
     * position that was current when the narrowing was invoked.
     */
    widen(preserveOffset = false) {
        const narrow = __classPrivateFieldGet(this, _narrows).pop();
        if (narrow) {
            __classPrivateFieldSet(this, _left, narrow.prevLeft);
            __classPrivateFieldSet(this, _right, narrow.prevRight);
            if (!preserveOffset) {
                __classPrivateFieldSet(this, _offset, narrow.prevOffset);
            }
        }
    }
}
exports.Reader = Reader;
_text = new WeakMap(), _vfile = new WeakMap(), _location = new WeakMap(), _offset = new WeakMap(), _left = new WeakMap(), _right = new WeakMap(), _narrows = new WeakMap();
//# sourceMappingURL=reader.js.map