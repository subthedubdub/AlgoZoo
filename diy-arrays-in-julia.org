:PROPERTIES:
:ID:      diy-arrays-in-julia
:AUTHOR:  Michael Kovarik
:TAGS:    julia data-structures bare-metal
:DATE:    3000-01-01
:UPDATED: 3000-01-01
:END:

#+title: DIY Arrays in Julia

The =Array= type is one of the most widely-used built-ins Julia programming
language. And it is a performant and versatile.

In this post, we will attempt to create our own =Array= implementation. We
begin by making a few convenient imports:

#+begin_src julia :tangle yes
import Base.Libc: malloc, free, realloc
import Base: getindex, setindex!, firstindex, lastindex
using Test
#+end_src

#+RESULTS:

* The Buffer

Before we implement the array, it is useful to first establish a low-level
interface to system memory. In particular, we want the ability to load and
retrieve a sequence of homogenously-typed objects in a contiguous chunk of
virtual memory. We will call such a container a *buffer*, which is roughly
analogous to an array in C.

The following functionality will be implemented:

- A constructor function which creates a buffer by allocating system memory
  (=Buffer()=)
- Safe point access methods (=getindex=, =setindex!=, =fistindex=, =lastindex=).
- The ability to efficiently copy data from one buffer into another buffer.
- The ability to resize a =Buffer=.
- Automatic, safe freeing of buffer data.

** Pointers and Memory Management

Our buffer implementation is really low-level. It requires that we make use
of Julia's memory management interfaces.

They key is to use pointers, represented in Julia as the parametrized
=Ptr{T}= type. An instance =Ptr{T}= represents a
C-like pointer to an object of type =T=. For arrays and mutable structs,
one can extract a pointer by invoking =pointer_from_objref(obj)=.


** Constructing a Buffer

A =Buffer= object contains two attributes: the address corresponding to the
first item of the buffer, and the number of items in the buffer.

#+begin_src julia :tangle yes
mutable struct Buffer{T}
    addr::Ptr{T}
    size::Int
end

Buffer{T}(size::Int) where T = begin
    bytewidth = size * sizeof(T)
    ptr_alloc = malloc(bytewidth)
    ptr_alloc == C_NULL && throw("Memory Allocation Failed")
    buff = Buffer{T}(Ptr{T}(ptr_alloc), size)
    finalizer(buff) do b
        Base.Libc.free(b.addr)
    end
    return buff
end
#+end_src

Some notes:

- The =sizeof(T)= function returns the number of bytes required
  to store an object of type =T= (not including the sizes of any
  referenced objects).
- =Base.Libc.malloc(size)= allocates =size= bytes of data and
  returns the address of the first byte. However, it may fail,
  returning instead a null pointer (=C_NULL=). We check for this
  and throw an exception.
- The function passed into =finalizer(f, x)= gets called whenever
  =x= gets garbaged-collected. In our case, we use it to call
  =Base.Libc.free(ptr)=, which frees up the memory allocated by
  our previous call to =malloc=. Failing to do this would result
  in a memory-leak.

** Point Access Methods

#+begin_src julia :tangle yes
setindex!(buff::Buffer{T}, obj::T, idx::Int) where T = begin
    @boundscheck idx <= buff.size || throw(BoundsError("Out of Bounds"))
    unsafe_store!(buff.addr, obj, idx)
end

getindex(buff::Buffer{T}, idx::Int) where T = begin
    @boundscheck idx <= buff.size || throw(BoundsError("Out of Bounds"))
    unsafe_load(buff.addr, idx)
end

firstindex(buff::Buffer) = 1
lastindex(buff::Buffer) = buff.size
#+end_src

Some notes:

- Extending these four =Base= methods to accept =Buffer= objects allows ua to use Julia's built-in indexing
  syntax (e.g. =buff[idx]=val=) for loading and retrieving data.
- The =@boundscheck= macro tags a piece of code. It can be elided when the enclosing function is called with
  =@inbounds=. This is a minor optimization.
- =getindex= does not check if the data has been initialized. That is, calling =getindex= before =setindex!=
  will return garbage.

We are now in a position to add some basic unit testing:

#+begin_src julia :tangle yes
@testset "BufferAccessTests" begin
    buff = Buffer{Float64}(16)
    @test buff.size == 16
    buff[6] = 3.14
    @test buff[6] == 3.14
    @test_throws BoundsError buff[17]
    @test_throws BoundsError buff[17] = buff[6]
end
#+end_src

** Resizing a Buffer

#+begin_src julia :tangle yes
resize!(buff::Buffer{T}, size::Int) where T = begin
    bytewidth = size * sizeof(T)
    addr = realloc(buff.addr, bytewidth)
    addr == C_NULL && throw("Failed to reallocate memory buffer")
    buff.size = size
    buff.addr = Ptr{T}(addr)
end
#+end_src


#+begin_src julia :tangle yes
@testset "BufferResizeTests" begin
    Point = Tuple{Float64, Float64, Float64}
    buff = Buffer{Point}(4)
    resize!(buff, 8)
    @test buff.size == 8
    @test_throws BoundsError buff[9]
    @test typeof(buff[8]) == Point
    resize!(buff, 4)
    @test_throws BoundsError buff[8]
end
#+end_src


** Copying Buffer Data

#+begin_src julia :tangle yes
copy!(src::Buffer{T},
      dest::Buffer{T},
      idxsrc::Int,
      idxdest::Int,
      size::Int) where T = begin
    idxsrcend = idxsrc + size - 1
    idxdestend = idxdest + size - 1
    @boundscheck idxsrcend <= src.size || throw(BoundsError())
    @boundscheck idxdestend <= dest.size || throw(BoundsError())
    while idxsrc <= idxsrcend
        dest[idxdest] = src[idxsrc]
        idxdest += 1
        idxsrc += 1
    end
end
#+end_src


#+begin_src julia :tangle yes
@testset "BufferCopyTests" begin
    buff1 = Buffer{Int}(3)
    buff2 = Buffer{Int}(4)
    foreach(i -> buff1[i] = i, 1:3)
    foreach(i -> buff2[i] = 0, 1:4)
    copy!(buff1, buff2, 2, 3, 2)
    @test (buff2[1] == 0 &&
           buff2[2] == 0 &&
           buff2[3] == 2 &&
           buff2[4] == 3)
end
#+end_src


* Arrays

Our Array implementation will be based off of Buffers (as above), but with a
number of additional capabilities:

- Support for multi-dimensional indices.
- Support for fast views.
- Fast dequeue interface for one-dimensional arrays with automatic resizing.
- Iterator interface.

** Definition

#+begin_src julia :tangle yes
mutable struct MyArray{T, N} <: AbstractArray{T, N}
    data::Buffer{T}
    shape::NTuple{N, Int}
    offset::Int
end
#+end_src

Here, =shape= is the length of the array along each of its =N= dimensions.

** Vectors

A vector is an array with one dimension.

#+begin_src julia :tangle yes
MyVector{T} = MyArray{T, 1}

# construct an empty vector
MyVector{T}() where T = MyVector{T}(Buffer{T}(0), (0,))

# Queue interface
import Base: pop!, push!

pop!(v::MyVector{T}) where T = begin
    @boundscheck v.shape[0] > 0 || throw(BoundsError())
    idxbuff = v.shape[0] + v.offset - 1
    idxbuff = idxbuff - v.data.size * (idxbuff > v.data.size)
    v.shape[0] -= 1
    v.data[idxbuff]
end
push!(v::MyVector{T}, val::T) where T = begin
    (v.shape[0] < v.data.size) || resize!(v.data, 2 * v.data.size + 1)
    idxbuff = v.shape[0] + v.offset - 1
    idxbuff = idxbuff - v.data.size * (idxbuff > v.data.size)
    @inbounds v.data[idxbuff] = val
    v.shape[0] += 1
end
#+end_src
