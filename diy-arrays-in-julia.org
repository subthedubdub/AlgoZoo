:PROPERTIES:
:ID:      diy-arrays-in-julia
:AUTHOR:  Michael Kovarik
:TAGS:    julia data-structures bare-metal
:DATE:    3000-01-01
:UPDATED: 3000-01-01
:END:

#+title: DIY Arrays in Julia
#+auto_tangle: t

We go over how to implement a multidimensional array in Julia,
similar to the =Array= built-in.

First, some useful imports:

#+begin_src julia :tangle yes
import Base.Libc: malloc, free, realloc
import Base: getindex, setindex!, firstindex, lastindex
using Test
#+end_src

#+RESULTS:

* The Buffer

Before we implement the array, it is useful to first establish a low-level
interface to system memory. In particular, we want the ability to load and
retrieve a sequence of homogenously-typed objects in a contiguous chunk of
virtual memory. We will call such a container a *buffer*, which is roughly
analogous to an array in C.

The following functionality will be implemented:

- A constructor function which creates a buffer by allocating system memory
  (=Buffer()=)
- Safe point access methods (=getindex=, =setindex!=, =fistindex=, =lastindex=).
- The ability to efficiently copy data from one buffer into another buffer.
- The ability to resize a =Buffer=.
- Automatic, safe freeing of buffer data.

** Pointers and Memory Management

Our buffer implementation is really low-level. It requires that we make use
of Julia's memory management interfaces.

They key is to use pointers, represented in Julia as the parametrized
=Ptr{T}= type. An instance =Ptr{T}= represents a
C-like pointer to an object of type =T=. For arrays and mutable structs,
one can extract a pointer by invoking =pointer_from_objref(obj)=.


** Constructing a Buffer

A =Buffer= object contains two attributes: the address corresponding to the
first item of the buffer, and the number of items in the buffer.

#+begin_src julia :tangle yes
mutable struct Buffer{T}
    addr::Ptr{T}
    size::Int
end

Buffer{T}(size::Int) where T = begin
    bytewidth = size * sizeof(T)
    ptr_alloc = malloc(bytewidth)
    ptr_alloc == C_NULL && throw("Memory Allocation Failed")
    buff = Buffer{T}(Ptr{T}(ptr_alloc), size)
    finalizer(b -> free(b.addr), buff)
    return buff
end
#+end_src

Some notes:

- The =sizeof(T)= function returns the number of bytes required
  to store an object of type =T= (not including the sizes of any
  referenced objects).
- =Base.Libc.malloc(size)= allocates =size= bytes of data and
  returns the address of the first byte. However, it may fail,
  returning instead a null pointer (=C_NULL=). We check for this
  and throw an exception.
- The function passed into =finalizer(f, x)= gets called whenever
  =x= gets garbaged-collected. In our case, we use it to call
  =Base.Libc.free(ptr)=, which frees up the memory allocated by
  our previous call to =malloc=. Failing to do this would result
  in a memory-leak.
- The Julia compiler is smart. The calculation of =bytewidth= is
  done at compile-time.

** Point Access Methods

#+begin_src julia :tangle yes
setindex!(buff::Buffer{T}, obj::T, idx::Int) where T = begin
    @boundscheck idx <= buff.size || throw(BoundsError("Out of Bounds"))
    unsafe_store!(buff.addr, obj, idx)
end

getindex(buff::Buffer{T}, idx::Int) where T = begin
    @boundscheck idx <= buff.size || throw(BoundsError("Out of Bounds"))
    unsafe_load(buff.addr, idx)
end

firstindex(buff::Buffer) = 1
lastindex(buff::Buffer) = buff.size
#+end_src

Some notes:

- Extending these four =Base= methods to accept =Buffer= objects allows ua to use Julia's built-in indexing
  syntax (e.g. =buff[idx]=val=) for loading and retrieving data.
- The =@boundscheck= macro tags a piece of code. It can be elided when the enclosing function is called with
  =@inbounds=. This is a minor optimization.
- =getindex= does not check if the data has been initialized. That is, calling =getindex= before =setindex!=
  will return garbage.

We are now in a position to add some basic unit testing:

#+begin_src julia :tangle yes
@testset "BufferAccessTests" begin
    buff = Buffer{Float64}(16)
    @test buff.size == 16
    buff[6] = 3.14
    @test buff[6] == 3.14
    @test_throws BoundsError buff[17]
    @test_throws BoundsError buff[17] = buff[6]
end
#+end_src

** Resizing a Buffer

#+begin_src julia :tangle yes
resize!(buff::Buffer{T}, size::Int) where T = begin
    bytewidth = size * sizeof(T)
    addr = realloc(buff.addr, bytewidth)
    addr == C_NULL && throw("Failed to reallocate memory buffer")
    buff.size = size
    buff.addr = Ptr{T}(addr)
end
#+end_src


#+begin_src julia :tangle yes
@testset "BufferResizeTests" begin
    Point = Tuple{Float64, Float64, Float64}
    buff = Buffer{Point}(4)
    resize!(buff, 8)
    @test buff.size == 8
    @test_throws BoundsError buff[9]
    @test typeof(buff[8]) == Point
    resize!(buff, 4)
    @test_throws BoundsError buff[8]
end
#+end_src


** Copying Buffer Data

#+begin_src julia :tangle yes
copy!(src::Buffer{T},
      dest::Buffer{T},
      idxsrc::Int,
      idxdest::Int,
      size::Int) where T = begin
    idxsrcend = idxsrc + size - 1
    idxdestend = idxdest + size - 1
    @boundscheck idxsrcend <= src.size || throw(BoundsError())
    @boundscheck idxdestend <= dest.size || throw(BoundsError())
    while idxsrc <= idxsrcend
        dest[idxdest] = src[idxsrc]
        idxdest += 1
        idxsrc += 1
    end
end
#+end_src


#+begin_src julia :tangle yes
@testset "BufferCopyTests" begin
    buff1 = Buffer{Int}(3)
    buff2 = Buffer{Int}(4)
    foreach(i -> buff1[i] = i, 1:3)
    foreach(i -> buff2[i] = 0, 1:4)
    copy!(buff1, buff2, 2, 3, 2)
    @test (buff2[1] == 0 &&
           buff2[2] == 0 &&
           buff2[3] == 2 &&
           buff2[4] == 3)
end
#+end_src


* Arrays

Our Array implementation will be based off of Buffers (as above), but with a
number of additional capabilities:

- Support for multi-dimensional indices.
- Support for fast views.
- Fast dequeue interface for one-dimensional arrays with automatic resizing.
- Iterator interface.

** Definition

#+begin_src julia :tangle yes
mutable struct MyArray{T, N} <: AbstractArray{T, N}
    data::Buffer{T}
    size::NTuple{N, Int}
    len::Int
    offset::Int
end

MyArray{T,N}(size...) where {T,N} = begin
    len = prod(size)
    data = Buffer{T}(len)
    MyArray{T,N}(data, size, len, 1)
end
#+end_src

Here, =size= is the length of the array along each of its =N= dimensions. For
example, if the shape of our array is =(2,3,6)=, then the array contains 36 items
(=2*3*6=). Such an array is indexed by a triplet of integers =(i, j, k)=, where
=i= ranges from 1 to 2, =j= ranges from 1 to 3, and =k= ranges from 1 to 6. The
=len= is just the product of the integers in =size=. This can be calculated on the
fly. But it is used for index lookups, so caching it is faster.

The =offset= attribute specifies where the array "begins" in the underlying data
buffer. It can range from 1 to =data.size=, inclusive. Allowing arbitrary
offsets makes it possible to implement fast =pushfirst!= and =popfirst!= methods.


#+begin_src julia :tangle yes
@testset "ArrayTests" begin
    arr = MyArray{Float64,2}(3,2)
    @test arr.data.size == 6
end
#+end_src


** Indexing

Before we begin, it is good to have some helper function that converts between
cartesian and linear indices:

#+begin_src julia :tangle yes
cartesian2linear(A::MyArray{T,N}, I) where {T,N} = begin
    idx = A.offset + I[1]
    cumprod = 1
    for k in 2:length(A.size)
        cumprod *= A.size[k - 1]
        idx += I[k] * cumprod
    end
    idx = idx > A.len ? idx - A.len : idx
    return idx
end
#+end_src

Let us imagine that the offset is 1. Denote the size tuple as \((s_1, s_2, \ldots, s_N)\).
And denote the index tuple as \((i_1, i_2, \ldots, i_N)\). The
corresponding linear index is:

\[1 + \sum_{k=1}^{N}(i_k-1)\prod_{j=1}^{k-1}s_j\]

This mapping is bijective. That is, it establishes a one-to-one mapping between all
cartesian and linear indices within range. Note that this is not the only such mapping
with this property. Other mappings may even result in better performance depending on
access patterns.

Since the array data may not begin at the start of the buffer data (=offset>1=),
we must also add some code to "wrap around" to the beginning of the buffer.

#+begin_src julia :tangle yes
import Base: size

size(a::MyArray) = a.size

getindex(A::MyArray{T,N}, I::Vararg{Int, N}) where {T,N} = begin
    @boundscheck all(i <= len for (i, len) in zip(I, A.size)) || throw(BoundsError())
    idxbuff = cartesian2linear(A, I)
    @inbounds A.data[idxbuff]
end

setindex!(A::MyArray{T,N}, v::T, I::Vararg{Int, N}) where {T,N} = begin
    @boundscheck all(i <= len for (i, len) in zip(I, A.size)) || throw(BoundsError())
    idxbuff = cartesian2linear(A, I)
    @inbounds A.data[idxbuff] = v
end
#+end_src


And, of course, some basic tests:

#+begin_src julia :tangle yes
@testset "ArrayBasicTests" begin
    arr = MyArray{NTuple{2, Int}, 2}(3,2)
    for i in 1:3, j in 1:2
        arr[i, j] = (i, j)
        @test arr[i, j] == (i, j)
    end
end
#+end_src

#+RESULTS:

** Optimizing Index Calculation

For cache-local access, access computation is dominated by index computation. To retrieve even a single
element of
$(s_1, \ldots, s_N)$,


** Vectors

A vector is an array with one dimension.

#+begin_src julia :tangle yes
MyVector{T} = MyArray{T, 1}

# construct an empty vector
MyVector{T}() where T = MyVector{T}(Buffer{T}(0), (0,))

# Queue interface
import Base: pop!, push!

pop!(v::MyVector{T}) where T = begin
    @boundscheck v.shape[0] > 0 || throw(BoundsError())
    idxbuff = v.shape[0] + v.offset - 1
    idxbuff = idxbuff - v.data.size * (idxbuff > v.data.size)
    v.shape[0] -= 1
    v.data[idxbuff]
end
push!(v::MyVector{T}, val::T) where T = begin
    (v.shape[0] < v.data.size) || resize!(v.data, 2 * v.data.size + 1)
    idxbuff = v.shape[0] + v.offset - 1
    idxbuff = idxbuff - v.data.size * (idxbuff > v.data.size)
    @inbounds v.data[idxbuff] = val
    v.shape[0] += 1
end
#+end_src
